<!doctype html> 
<html lang="en"> 
<head> 
<meta charset="UTF-8" />
<title>Dungeon maker</title>
<link href="resources/main.css" rel="stylesheet" type="text/css" />
<link href="resources/dungeon_parts.css" rel="stylesheet" type="text/css" />
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script type="text/javascript">
var maxrow = 10;
var maxcol = 14; // 14x10 e' la dimensione dell'area gioco per scratch
var maxsize = 5;
var room_list = new Array();

function rand_between(min, max) {
    // min and max inclusive
    return Math.floor(Math.random() * (max-min+1)) + min;
}

$(document).ready(function () {
    var j,k;
    
    var grid_width = 32 * maxcol + maxcol + 1; // remember the border width of the cells
    
    for (j=1; j<=maxrow; j++) {
        var newrow = $("<div class=dng_row></div>");
        newrow.css("width",grid_width);
        $("#THE-MAP").append(newrow);
        for (k=1;k<=maxcol;k++) {
            var newcell = $("<div class='cell_rock dng_cell' id='C-" + k.toString() + "-R-" + j.toString() + "'>"+  k.toString() + "-" + j.toString()   +"</div>");
            newrow.append(newcell);
        }
    }
});

function get_terrain_id (id) {
    var classList;
    try { // just in case the id is not existent
        classList = $(id).attr('class').split(/\s+/);
        for (var i = 0; i < classList.length; i++) {
            if (classList[i].substring(0,4) === 'cell') {
                return classList[i];
            }
        }
    } catch (error) {
        return false;
    }
    return false;
}

function get_terrain_colrow(c, r) {
    var id = "#C-" + c + "-R-" + r;
    return get_terrain_id(id);
} 

function make_cell_id(col, row) {
    return "#C-" + col + "-R-" + row;
}

function are_all_the_same(t1, t2, t3, t4) {
    if ((t1 == t2) && (t1 == t3) && (t1 == t4)) return true;
    return false;
}

function is_corridor_colrow(c, r) {
    let grid = [make_cell_id(c-1,r-1),make_cell_id(c,r-1),make_cell_id(c+1,r-1), // 0 1 2
                make_cell_id(c-1,r),make_cell_id(c,r),make_cell_id(c+1,r), // 3 4 5
                make_cell_id(c-1,r+1),make_cell_id(c,r+1),make_cell_id(c+1,r+1)]; // 6 7 8
    
    for (var i = 0; i < grid.length; i++) {
        grid[i] = get_terrain_id(grid[i]);
    }
    if (grid[4] == 'cell_floor') { // center cell
        /* if a square of 4 tiles in the matrix contain the 
           same terrain of the central [4] then it's NOT a corridor */
        if (are_all_the_same(grid[4], grid[0], grid[1], grid[3])) return false;
        if (are_all_the_same(grid[4], grid[1], grid[2], grid[5])) return false;
        if (are_all_the_same(grid[4], grid[3], grid[6], grid[7])) return false;
        if (are_all_the_same(grid[4], grid[5], grid[7], grid[8])) return false;
        // else
        return true;
    } 
    //else 
    return false;
}

function is_room_colrow(c, r) {
    // checks if the cell is part of a room
    let grid = [make_cell_id(c-1,r-1),make_cell_id(c,r-1),make_cell_id(c+1,r-1), // 0 1 2
                make_cell_id(c-1,r),make_cell_id(c,r),make_cell_id(c+1,r), // 3 4 5
                make_cell_id(c-1,r+1),make_cell_id(c,r+1),make_cell_id(c+1,r+1)]; // 6 7 8
    
    for (var i = 0; i < grid.length; i++) {
        grid[i] = get_terrain_id(grid[i]);
    }
    if (grid[4] == 'cell_floor') { // center cell
        /* if a square of 4 tiles in the matrix contain the 
           same terrain of the central [4] then it IS a room */
        if (are_all_the_same(grid[4], grid[0], grid[1], grid[3])) return true;
        if (are_all_the_same(grid[4], grid[1], grid[2], grid[5])) return true;
        if (are_all_the_same(grid[4], grid[3], grid[6], grid[7])) return true;
        if (are_all_the_same(grid[4], grid[5], grid[7], grid[8])) return true;
        // else
        return false;
    } 
    //else 
    return false;
    
    
}
var rname = ""; // for debug only room name
function dig(c, r) {
    var id = "#C-" + c + "-R-" + r;
    //console.log(id);
    var classList = $(id).attr('class').split(/\s+/);
    $.each(classList, function(index, item) {
        if (item.substring(0,4) === 'cell') {
            $(id).removeClass(item);
        }
    });    
    $(id).html("RM:" + rname);
    $(id).addClass('cell_floor');
}

function wall(c,r) {
    var id = make_cell_id(c,r);
    //console.log(id);
    var classList = $(id).attr('class').split(/\s+/);
    $.each(classList, function(index, item) {
        if (item.substring(0,4) === 'cell') {
            $(id).removeClass(item);
        }
    });    
    $(id).html("WL:" + rname);
    $(id).addClass('cell_wall'); 
}

function dig_room(cc, rr, wd, hg) {
    for (var c = cc; c < cc+wd; c++ ) {
        for (var r = rr; r < rr+hg; r++) {
           dig(c,r);
        }
    }
    var new_room = new Object();
    new_room.col = cc;
    new_room.row = rr;
    new_room.cols = wd;
    new_room.rows = hg;
    room_list.push(new_room);
    // draw the wall around the room
    // corners
    wall(cc-1,rr-1);
    wall(cc-1,rr+hg);
    wall(cc+wd,rr-1);
    wall(cc+wd,rr+hg);
    // rows top and bottom
    for (var c = cc; c < cc+wd; c++) {
        wall(c,rr-1); 
        wall(c,rr+hg);
    }
    //columns left and right
    for (var r = rr; r < rr+hg; r++) {
        wall(cc-1,r);
        wall(cc+wd,r);
    }

    return [wd, hg]; //??? really ???
    //return [0,0]; 
}

function test_room(cc, rr, wd, hg) {
    // initial check ... not on/out the borders
    console.log("Test room. Col: " + cc + "  Row: " + rr + "  Wid: " + wd + "  Hht: " + hg)
    if (cc+wd >= maxcol) return false;
    if (rr+hg >= maxrow) return false;
    // checks if the area is empty
    for (var c = cc; c < cc+wd; c++ ) {
        for (var r = rr; r < rr+hg; r++) {
            if (get_terrain_colrow(c,r)=='cell_floor') return false;
        }
    }
    // check that there is a free border of rock around
    // row above/below
    for (var c = cc-1; c <= cc+wd; c++) {
        if (get_terrain_colrow(c,rr-1)=='cell_floor') return false;
        if (get_terrain_colrow(c,rr+hg)=='cell_floor') return false;
    }
    // column left/right (corners already checked above)
    for (var r = rr; r < rr+hg; r++) {
        if (get_terrain_colrow(cc-1,r)=='cell_floor') return false;
        if (get_terrain_colrow(cc+wd,r)=='cell_floor') return false;
    }
    console.log("Room is diggable")
    return true;
}

function areas_dig(rooms) {
    //try to dig the indicated number of rooms distributing 
    //around the available space
    var avg_size = maxsize*maxsize;
    var ret, col, row, wdt, hgt;
    var attempts = 0;
    var sel_method = "RND"; // selection method for a free area
    for (var digrooms=0; digrooms<rooms; digrooms++) {
        rname = digrooms; //maxsize*maxsize - avg_size,
        do {
            if (sel_method == 'RND') {
                col = rand_between(2, maxcol - maxsize);
                row = rand_between(2, maxrow - maxsize);
                wdt = rand_between(2, Math.floor(Math.sqrt(avg_size)));
                hgt = rand_between(2, Math.floor(Math.sqrt(avg_size)));
            } else {
                col++;
                if (col > maxcol - 2) {
                    col = 2;
                    row++;
                    if (row > maxrow - 2) {
                        console.log("Reached the end of the map");
                        return;
                    }
                }
            }
            attempts++;
            if ((attempts > 300) && (sel_method == 'RND')) {
                console.log("Switching to iterative method");
                col = 2;
                row = 2;
                sel_method = 'ITER';
            }
            if (attempts > 1000) {
                console.log("Too many attempts");
                return;
            }
        } while(!test_room(col, row, wdt, hgt));
        ret = dig_room (col, row, wdt, hgt);
        if (ret[0] != 0) {
            avg_size = ((avg_size + ret[0]*ret[1]) / 2); // this is the average area
        } // otherwise the digging failed but we go on with a new room
    }
    console.log("Solved after " + attempts + " attempts");
}

// mole algorithm saved in old versions, see gitHub

</script>

</head>

    
    
<body>
<input type=button onclick="areas_dig(5)" value="start">

<div class='dungeon_map' id='THE-MAP'>

</div>



</body>
</html>