<!doctype html> 
<html lang="en"> 
<head> 
<meta charset="UTF-8" />
<title>Dungeon maker</title>
<link href="resources/main.css" rel="stylesheet" type="text/css" />
<link href="resources/dungeon_parts.css" rel="stylesheet" type="text/css" />
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script type="text/javascript">
var maxrow = 10;
var maxcol = 14; // 14x10 e' la dimensione dell'area gioco per scratch
var maxsize = 4;
var room_list = new Array();

function rand_between(min, max) {
    // min and max inclusive
    return Math.floor(Math.random() * (max-min+1)) + min;
}

$(document).ready(function () {
    var j,k;
    
    var grid_width = 32 * maxcol + maxcol + 1; // remember the border width of the cells
    
    for (j=1; j<=maxrow; j++) {
        var newrow = $("<div class=dng_row></div>");
        newrow.css("width",grid_width);
        $("#THE-MAP").append(newrow);
        for (k=1;k<=maxcol;k++) {
            var newcell = $("<div class='cell_rock dng_cell' id='C-" + k.toString() + "-R-" + j.toString() + "'>"+  k.toString() + "-" + j.toString()   +"</div>");
            newrow.append(newcell);
        }
    }
});

function get_terrain_id (id) {
    var classList;
    try { // just in case the id is not existent
        classList = $(id).attr('class').split(/\s+/);
        for (var i = 0; i < classList.length; i++) {
            if (classList[i].substring(0,4) === 'cell') {
                return classList[i];
            }
        }
    } catch (error) {
        return false;
    }
    return false;
}

function get_terrain_colrow(c, r) {
    var id = "#C-" + c + "-R-" + r;
    return get_terrain_id(id);
} 

function make_cell_id(col, row) {
    return "#C-" + col + "-R-" + row;
}

function are_all_the_same(t1, t2, t3, t4) {
    if ((t1 == t2) && (t1 == t3) && (t1 == t4)) return true;
    return false;
}

function is_corridor_colrow(c, r) {
    let grid = [make_cell_id(c-1,r-1),make_cell_id(c,r-1),make_cell_id(c+1,r-1), // 0 1 2
                make_cell_id(c-1,r),make_cell_id(c,r),make_cell_id(c+1,r), // 3 4 5
                make_cell_id(c-1,r+1),make_cell_id(c,r+1),make_cell_id(c+1,r+1)]; // 6 7 8
    
    for (var i = 0; i < grid.length; i++) {
        grid[i] = get_terrain_id(grid[i]);
    }
    if (grid[4] == 'cell_floor') { // center cell
        /* if a square of 4 tiles in the matrix contain the 
           same terrain of the central [4] then it's NOT a corridor */
        if (are_all_the_same(grid[4], grid[0], grid[1], grid[3])) return false;
        if (are_all_the_same(grid[4], grid[1], grid[2], grid[5])) return false;
        if (are_all_the_same(grid[4], grid[3], grid[6], grid[7])) return false;
        if (are_all_the_same(grid[4], grid[5], grid[7], grid[8])) return false;
        // else
        return true;
    } 
    //else 
    return false;
}

function is_room_colrow(c, r) {
    // checks if the cell is part of a room
    let grid = [make_cell_id(c-1,r-1),make_cell_id(c,r-1),make_cell_id(c+1,r-1), // 0 1 2
                make_cell_id(c-1,r),make_cell_id(c,r),make_cell_id(c+1,r), // 3 4 5
                make_cell_id(c-1,r+1),make_cell_id(c,r+1),make_cell_id(c+1,r+1)]; // 6 7 8
    
    for (var i = 0; i < grid.length; i++) {
        grid[i] = get_terrain_id(grid[i]);
    }
    if (grid[4] == 'cell_floor') { // center cell
        /* if a square of 4 tiles in the matrix contain the 
           same terrain of the central [4] then it IS a room */
        if (are_all_the_same(grid[4], grid[0], grid[1], grid[3])) return true;
        if (are_all_the_same(grid[4], grid[1], grid[2], grid[5])) return true;
        if (are_all_the_same(grid[4], grid[3], grid[6], grid[7])) return true;
        if (are_all_the_same(grid[4], grid[5], grid[7], grid[8])) return true;
        // else
        return false;
    } 
    //else 
    return false;
    
    
}

function dig(c, r) {
    var id = "#C-" + c + "-R-" + r;
    //console.log(id);
    var classList = $(id).attr('class').split(/\s+/);
    $.each(classList, function(index, item) {
        if (item.substring(0,4) === 'cell') {
            $(id).removeClass(item);
        }
    });    
    $(id).addClass('cell_floor');
}

function dig_room(variance) {
    // variance is relative to the average size
    var cc = rand_between(2, maxcol - maxsize-1); // the first corner of the room
    var rr = rand_between(2, maxrow - maxsize-1);
    var cols = rand_between(2,maxsize) + Math.floor(variance/2); // size of the room
    var rows = rand_between(2,maxsize) + Math.floor(variance/2);
    var r = 0;
    var c = 0;
    var new_room = new Object();
    if (cols < 2) {cols = 2}
    if (rows < 2) {rows = 2}
    // try not to overlap
    var pos_ok = false;
    var attempts = 0;
    while ((!pos_ok) && (attempts < 100)) {
        pos_ok = true;
        for (cc_test=cc; cc_test<=cc+cols; cc_test++) {
            for (rr_test=rr; rr_test<=rr+rows; rr_test++) {
                if (get_terrain_colrow(cc_test, rr_test) == 'cell_floor') {
                    pos_ok = false;
                    break;
                }
            }
            if (!pos_ok) break;
        }
    
    
        if (!pos_ok) { 
            // re-randomize room    
            cc = rand_between(2, maxcol - 7);
            rr = rand_between(2, maxrow - 7);
            attempts++;
            console.log("Retry");
        } else {
            console.log("Digging @ ", cc,rr, "room of ", cols,rows);
            t = 0;
            while(r<rows) {
                while(c<cols) {
                    dig(c+cc,r+rr);
                    c++;
                }
                r++;
                c = 0;
            }
            new_room.col = cc;
            new_room.row = rr;
            new_room.cols = cols;
            new_room.rows = rows;
            room_list.push(new_room);
            return [cols, rows];
        }
    }
    console.log("Giving up");
    return [0,0]; 
}


function areas_dig(rooms) {
    //try to dig the indicated number of rooms distributing 
    //around the available space
    var avg_size = maxsize*maxsize;
    var ret;
    while (rooms > 0) {
        ret = dig_room (maxsize*maxsize - avg_size);
        if (ret[0] != 0) {
            avg_size = Math.floor((avg_size + ret[0]*ret[1]) / 2)
        } // otherwise the digging failed but we go on with a new room
        rooms = rooms - 1;
    }
}

// mole algorithm saved in old versions, see gitHub

</script>

</head>

    
    
<body>
<input type=button onclick="areas_dig(3)" value="start">

<div class='dungeon_map' id='THE-MAP'>

</div>



</body>
</html>