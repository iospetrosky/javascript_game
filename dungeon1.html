<!doctype html> 
<html lang="en"> 
<head> 
<meta charset="UTF-8" />
<title>Dungeon maker</title>
<link href="resources/main.css" rel="stylesheet" type="text/css" />
<link href="resources/dungeon_parts.css" rel="stylesheet" type="text/css" />
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script type="text/javascript">
var maxrow = Math.floor(10 * 1.3);
var maxcol = Math.floor(14 * 1.3); // 14x10 e' la dimensione dell'area gioco per scratch
var maxsize = 5;
var room_list = new Array();

function rand_between(min, max) {
    // min and max inclusive
    return Math.floor(Math.random() * (max-min+1)) + min;
}

$(document).ready(function () {
    var j,k;
    
    var grid_width = 32 * maxcol + maxcol + 1; // remember the border width of the cells
    
    for (j=1; j<=maxrow; j++) {
        var newrow = $("<div class=dng_row></div>");
        newrow.css("width",grid_width);
        $("#THE-MAP").append(newrow);
        for (k=1;k<=maxcol;k++) {
            var newcell = $("<div class='cell_rock dng_cell' id='C-" + k.toString() + "-R-" + j.toString() + "'>"+  k.toString() + "-" + j.toString()   +"</div>");
            newrow.append(newcell);
        }
    }
});

function get_terrain_id (id) {
    var classList;
    try { // just in case the id is not existent
        classList = $(id).attr('class').split(/\s+/);
        for (var i = 0; i < classList.length; i++) {
            if (classList[i].substring(0,4) === 'cell') {
                return classList[i];
            }
        }
    } catch (error) {
        return false;
    }
    return false;
}

function get_terrain_colrow(c, r) {
    var id = "#C-" + c + "-R-" + r;
    return get_terrain_id(id);
} 

function make_cell_id(col, row) {
    return "#C-" + col + "-R-" + row;
}

function are_all_the_same(t1, t2, t3, t4) {
    if ((t1 == t2) && (t1 == t3) && (t1 == t4)) return true;
    return false;
}

var rname = ""; // for debug only room name
function dig(c, r) {
    var id = "#C-" + c + "-R-" + r;
    //console.log(id);
    var classList = $(id).attr('class').split(/\s+/);
    $.each(classList, function(index, item) {
        if (item.substring(0,4) === 'cell') {
            $(id).removeClass(item);
        }
    });    
    $(id).html("RM:" + rname);
    $(id).addClass('cell_floor');
}

function wall(c,r) {
    var id = make_cell_id(c,r);
    //console.log(id);
    var classList = $(id).attr('class').split(/\s+/);
    $.each(classList, function(index, item) {
        if (item.substring(0,4) === 'cell') {
            $(id).removeClass(item);
        }
    });    
    $(id).html("WL:" + rname);
    $(id).addClass('cell_wall'); 
}

function dig_room(cc, rr, wd, hg) {
    for (var c = cc; c < cc+wd; c++ ) {
        for (var r = rr; r < rr+hg; r++) {
           dig(c,r);
        }
    }
    var new_room = new Object();
    new_room.col = cc;
    new_room.row = rr;
    new_room.cols = wd;
    new_room.rows = hg;
    room_list.push(new_room);
    
    // draw the wall around the room
    // corners
    wall(cc-1,rr-1);
    wall(cc-1,rr+hg);
    wall(cc+wd,rr-1);
    wall(cc+wd,rr+hg);
    // rows top and bottom
    for (var c = cc; c < cc+wd; c++) {
        wall(c,rr-1); 
        wall(c,rr+hg);
    }
    //columns left and right
    for (var r = rr; r < rr+hg; r++) {
        wall(cc-1,r);
        wall(cc+wd,r);
    }
    
    return [wd, hg]; //used to calculate the average size
    //return [0,0]; 
}

function test_room(cc, rr, wd, hg) {
    // initial check ... not on/out the borders
    console.log("Test room. Col: " + cc + "  Row: " + rr + "  Wid: " + wd + "  Hht: " + hg)
    if (cc+wd >= maxcol) return false;
    if (rr+hg >= maxrow) return false;
    // checks if the area is empty
    for (var c = cc; c < cc+wd; c++ ) {
        for (var r = rr; r < rr+hg; r++) {
            if (get_terrain_colrow(c,r)=='cell_floor') return false;
        }
    }
    // check that there is a free border of rock around
    // row above/below
    for (var c = cc-1; c <= cc+wd; c++) {
        if (get_terrain_colrow(c,rr-1)=='cell_floor') return false;
        if (get_terrain_colrow(c,rr+hg)=='cell_floor') return false;
    }
    // column left/right (corners already checked above)
    for (var r = rr; r < rr+hg; r++) {
        if (get_terrain_colrow(cc-1,r)=='cell_floor') return false;
        if (get_terrain_colrow(cc+wd,r)=='cell_floor') return false;
    }
    console.log("Room is diggable")
    return true;
}

function areas_dig(rooms) {
    //try to dig the indicated number of rooms distributing 
    //around the available space
    var avg_size = maxsize*maxsize;
    var ret, col, row, wdt, hgt;
    var attempts = 0;
    var sel_method = "RND"; // selection method for a free area
    for (var digrooms=0; digrooms<rooms; digrooms++) {
        rname = digrooms; //maxsize*maxsize - avg_size,
        do {
            if (sel_method == 'RND') {
                col = rand_between(2, maxcol - maxsize);
                row = rand_between(2, maxrow - maxsize);
                wdt = rand_between(2, Math.floor(Math.sqrt(avg_size)));
                hgt = rand_between(2, Math.floor(Math.sqrt(avg_size)));
            } else {
                col++;
                if (col > maxcol - 2) {
                    col = 2;
                    row++;
                    if (row > maxrow - 2) {
                        console.log("Reached the end of the map");
                        dig_corridors();
                        return;
                    }
                }
            }
            attempts++;
            if ((attempts > 300) && (sel_method == 'RND')) {
                console.log("Switching to iterative method");
                col = 2;
                row = 2;
                sel_method = 'ITER';
            }
            if (attempts > 1000) {
                console.log("Too many attempts");
                return;
            }
        } while(!test_room(col, row, wdt, hgt));
        ret = dig_room (col, row, wdt, hgt);
        if (ret[0] != 0) {
            avg_size = ((avg_size + ret[0]*ret[1]) / 2); // this is the average area
        } // otherwise the digging failed but we go on with a new room
    }
    console.log("Solved after " + attempts + " attempts");
    dig_corridors();
}

function dig_corridors() {
    function starting_cell(room) {
        var rnd_cell = rand_between(0, room.cols * room.rows - 1);
        return [rnd_cell % room.cols + room.col, 
                Math.floor(rnd_cell / room.cols) + room.row];
    }

    var r1, r2;
    for (var j=0; j < room_list.length -1; j++) {
        r1 = room_list[j];
        r2 = room_list[j+1];
        rname = j;
        // determine the starting cell within the room
        var row1, row2, col1, col2;
        [col1, row1] = starting_cell(r1);
        [col2, row2] = starting_cell(r2);
        // now dig between r1 and r2
        var x, y;
        if (row1 <= row2) {
            for (y=row1; y<=row2; y++) {
                dig(col1, y);
            }
        } else {
            for (y=row2; y<=row1; y++) {
                dig(col1, y);
            }
        }
        if (col1 <= col2) { 
            for (x=col1; x<=col2; x++) {
                dig(x,row2);
            }
        } else {
            for (x=col2; x<=col1; x++) {
                dig(x,row2);
            }
        }
    }
}
</script>

</head>

    
    
<body>
<input type=button onclick="areas_dig(4)" value="start">

<div class='dungeon_map' id='THE-MAP'>

</div>



</body>
</html>